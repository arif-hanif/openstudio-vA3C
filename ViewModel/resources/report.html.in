<!DOCTYPE html>
<html>
<head>
<title>OpenStudio Model</title>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<script src="http://mrdoob.github.io/three.js/build/three.min.js"></script>
<script src="http://mrdoob.github.io/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.16.1/TweenLite.min.js"></script>
</head>
<body>
<script>
var os_data = <%=os_data %>;

var info, renderer, scene, camera, controls, light;

var project, materials;

var raycaster;
var mouse;
var intersected, selected_material;

init();
animate();

function parseMaterials(json) {
  var materials = {};
  var loader = new THREE.MaterialLoader();
  for ( var i = 0, l = json.length; i < l; i ++ ) {
    var data = json[ i ];
    var material = loader.parse( data );
    material.uuid = data.uuid;
    materials[ data.name ] = material;
  }
  return materials;
};

function init() {

  var css = document.head.appendChild(document.createElement('style'));
  css.innerHTML = 'body { font:600 12pt monospace; margin:0; overflow:hidden; }';

  info = document.body.appendChild(document.createElement('div'));
  info.style.cssText = 'left:20px; position:absolute; top:0; width:100%;';
  info.innerHTML = '<div id=msg></div>';

  // Heads Up
  headsUp = document.body.appendChild(document.createElement('div'));
  headsUp.style.cssText = 'background-color:#ddd; border-radius:8px; padding:0 5px 10px; opacity:0.85; position:absolute; left:50px; text-align:left; z-index:10;';

  renderer = new THREE.WebGLRenderer({
    alpha: 1,
    antialias: true,
    clearColor: 0xffffff
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMapEnabled = true;
  renderer.shadowMapSoft = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 5000);
  camera.position.set(100, 100, 100);
  scene.add(camera); // for light to follow

  // Controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.minDistance = 10;
  controls.maxDistance = 1000;

  // Lights
  light = new THREE.AmbientLight(0xbbbbbb);
  scene.add(light);

  var axisHelper = new THREE.AxisHelper(50);
  scene.add(axisHelper);

  project = new THREE.Object3D();
  scene.add(project);
  
  var loader = new THREE.ObjectLoader();
  data = loader.parse(os_data);
  project.add(data);
  
  scene_objects = project.children[0].children;
  for ( object of scene_objects ) {
    edges = new THREE.EdgesHelper( object, 0x000000 );
    scene.add( edges );
  }
  
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  selected_material = new THREE.MeshPhongMaterial({
    color: 0xffff00,
    ambient: 0xffff00,
    specular: 0xffff00,
    emissive: 0xffff00,
    shininess: 50,
    side: THREE.DoubleSide
  });
  
  materials = parseMaterials(os_data.materials);

  document.addEventListener('click', onDocumentMouseClick, false);
}


function onDocumentMouseClick(event) {
  mouse.x = (event.clientX / renderer.domElement.width) * 2 - 1;
  mouse.y = -(event.clientY / renderer.domElement.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  intersects = raycaster.intersectObjects(project.children[0].children);

  if (intersects.length) {
    // new intersected object
    if (intersected != intersects[0].object) {
      // restore material on deselected
      if (intersected && intersected.lastMaterial) {
        intersected.material = intersected.lastMaterial;
      }

      intersected = intersects[0].object;

      // save material
      if (intersected && intersected.material) {
        intersected.lastMaterial = intersected.material;
      }

      intersected.material = selected_material;

      headsUp.style.left = 10 + 0.5 * window.innerWidth + mouse.x * 0.5 * window.innerWidth + 'px';
      headsUp.style.top = -10 + 0.5 * window.innerHeight - mouse.y * 0.5 * window.innerHeight + 'px';
      headsUp.style.display = '';

      var txt;
      switch (settings.renderBy) {
        case "Surface Type":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Surface Type: ' + intersected.userData.surfaceType + '<br>' +
                'Space Name: ' + intersected.userData.spaceName + '<br>' +
                '';
          break;
        case "Boundary":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Outside Boundary Condition: ' + intersected.userData.outsideBoundaryCondition + '<br>' +
                'Sun Exposure: ' + intersected.userData.sunExposure + '<br>' +
                'Wind Exposure: ' + intersected.userData.windExposure + '<br>' +
                '';
          break;
        case "Construction":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Construction Name: ' + intersected.userData.constructionName + '<br>' +
                '';
          break;
        case "Thermal Zone":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Thermal Zone: ' + intersected.userData.thermalZoneName + '<br>' +
                '';
          break;
        case "Space Type":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Space Type: ' + intersected.userData.spaceTypeName + '<br>' +
                '';
          break;        
        case "Building Story":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Story Name: ' + intersected.userData.buildingStoryName + '<br>' +
                '';
          break;
        case "Data":
          break;        
      }

      headsUp.innerHTML = txt;

    }

    document.body.style.cursor = 'pointer';
  } else {
    // restore material on deselected
    if (intersected && intersected.lastMaterial) {
      intersected.material = intersected.lastMaterial;
    }

    intersected = null;
    headsUp.style.display = 'none';
    document.body.style.cursor = 'auto';
  }

}

function animate(timestamp) {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
</script>
<script>
var endRadius = Math.sqrt(30000);
var cameraToPosition = function (position) {
  return function() {
    var startRadius = Math.sqrt(Math.pow(camera.position.x, 2)+Math.pow(camera.position.y, 2)+Math.pow(camera.position.z, 2));
    var target = {
      progress: 0,
      start: {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z,
        r: startRadius,
        theta: Math.acos(camera.position.z / startRadius),
        phi: Math.atan2(camera.position.y, camera.position.x)
      },
      end: {
        x: position.x,
        y: position.y,
        z: position.z,
        r: endRadius,
        theta: Math.acos(position.z / endRadius),
        phi: Math.atan2(position.y, position.x)
      }
    };
    /*console.debug('===========================');
    console.debug('START');
    console.debug('x: ' + camera.position.x + '    y: ' + camera.position.y + '    z: ' + camera.position.z);
    console.debug('θ: ' + (target.start.theta * 180 / Math.PI).toFixed(3) + '°    φ: ' + (target.start.phi * 180 / Math.PI).toFixed(3) + '°');
    console.debug('END');
    console.debug('x: ' + position.x + '    y: ' + position.y + '    z: ' + position.z);
    console.debug('θ: ' + (target.end.theta * 180 / Math.PI).toFixed(3) + '°    φ: ' + (target.end.phi * 180 / Math.PI).toFixed(3) + '°');
    console.debug('===========================');*/
    TweenLite.to(target, 1, {
      progress: 1,
      ease: Power3.easeInOut,
      onUpdate: function (tween) {
        var r = tween.target.start.r + tween.target.progress * (tween.target.end.r - tween.target.start.r);
        var theta = tween.target.start.theta + tween.target.progress * (tween.target.end.theta - tween.target.start.theta);
        var phi = tween.target.start.phi + tween.target.progress * (tween.target.end.phi - tween.target.start.phi);
        var x = r * Math.sin(theta) * Math.cos(phi);
        var y = r * Math.sin(theta) * Math.sin(phi);
        var z = r * Math.cos(theta);
        //console.debug('θ: ' + (theta * 180 / Math.PI).toFixed(3) + '°    φ: ' + (phi * 180 / Math.PI).toFixed(3) + '°');
        camera.position.set(x, y, z);
      },
      onUpdateParams: ["{self}"]
    });
  }
}

var settings = {
  renderBy: 'Surface Type',
  showStory: 'All Stories',
  zoomExtents: function () {
    console.log('View: extents');
  },
  xView: cameraToPosition(new THREE.Vector3(endRadius, 0, 0)),
  yView: cameraToPosition(new THREE.Vector3(0, endRadius, 0)),
  zView: cameraToPosition(new THREE.Vector3(0, 0, endRadius)),
  reset: cameraToPosition(new THREE.Vector3(100, 100, 100)),
  xSection: 0,
  ySection: 0,
  zSection: 0
};

var update = function (value) {


  renderBy = settings.renderBy;
  showStory = settings.showStory;
  allStories = (showStory == 'All Stories');

  scene_objects = project.children[0].children;
  for ( object of scene_objects ) {
  
    object.visible = true;
  
    if (allStories || showStory == object.userData.buildingStoryName){
      // no-op
    }else{
      object.visible = false;
    }
    
    var material = null;
    switch (renderBy) {
      case "Surface Type":
        material = materials[object.userData.surfaceTypeMaterialName];
        break;
      case "Boundary":
        material = materials[object.userData.boundaryMaterialName];
        break;
      case "Construction":
        material = materials[object.userData.constructionMaterialName];
        break;
      case "Thermal Zone":
        material = materials[object.userData.thermalZoneMaterialName];
        break;
      case "Space Type":
        material = materials[object.userData.spaceTypeMaterialName];
        break;        
      case "Building Story":
        material = materials[object.userData.buildingStoryMaterialName];
        break;
      case "Data":
        break;        
    }
  
    object.material = material;
    if ( material != null){
      object.material.needsUpdate = true; 
    }
  }
};

window.onload = function() {
  var gui = new dat.GUI();
    gui.add(settings, 'renderBy', ['Surface Type', 'Boundary', 'Construction', 'Thermal Zone', 'Space Type', 'Building Story', 'Data']).name('Render By').onChange(update);
    
    building_story_names = os_data.metadata.buildingStoryNames;
    building_story_names.unshift('All Stories');
    gui.add(settings, 'showStory', building_story_names).name('Show Story').onChange(update);
    
    var f1 = gui.addFolder('Camera');
    f1.add(settings, 'zoomExtents').name('Zoom extents');
    f1.add(settings, 'xView').name('X View');
    f1.add(settings, 'yView').name('Y View');
    f1.add(settings, 'zView').name('Z View');
    f1.add(settings, 'reset').name('Reset');
    f1.open();
    //var f2 = gui.addFolder('Section Cut');
    //f2.add(settings, 'xSection', 0, 360).name('X Section').onChange(function (value) {
    //  console.log('X cut: ' + value);
    //});
    //f2.add(settings, 'ySection', 0, 360).name('Y Section').onChange(function (value) {
    //  console.log('Y cut: ' + value);
    //});
    //f2.add(settings, 'zSection', 0, 360).name('Z Section').onChange(function (value) {
    //  console.log('Z cut: ' + value);
    //});
    //f2.open();
    
    update();
};
</script>
</body>
</html>