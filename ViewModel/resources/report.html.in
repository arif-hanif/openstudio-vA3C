<!DOCTYPE html>
<html>
<head>
<title>OpenStudio Model</title>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<script src="http://mrdoob.github.io/three.js/build/three.min.js"></script>
<script src="http://mrdoob.github.io/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.16.1/TweenLite.min.js"></script>
</head>
<body>
<script>
var os_data = <%=os_data %>;
var info, renderer, scene, camera, controls, light;
var perspectiveCamera, orthographicCamera, perspectiveControls, orthographicControls;
var project, materials, settings;

var raycaster;
var mouse;
var intersected, selected_material;

init();
animate();

function parseMaterials(json) {
  var materials = {};
  var loader = new THREE.MaterialLoader();
  for ( var i = 0, l = json.length; i < l; i ++ ) {
    var data = json[ i ];
    var material = loader.parse( data );
    material.uuid = data.uuid;
    materials[ data.name ] = material;
  }
  return materials;
};

function cameraLookAt() {
  return new THREE.Vector3(os_data.metadata.boundingBox.lookAtX, os_data.metadata.boundingBox.lookAtZ, -os_data.metadata.boundingBox.lookAtY);
};

function cameraRadius() {
  return 4 * os_data.metadata.boundingBox.lookAtR;
};

// theta is rotation about OpenStudio Z in degrees, phi is rotation above ground plane in degrees
function setCameraAngles(theta, phi, doTween) {
  var aim = cameraLookAt();

  var startRadius = Math.sqrt(Math.pow(camera.position.x - aim.x, 2) + Math.pow(camera.position.y - aim.y, 2) + Math.pow(camera.position.z - aim.z, 2));
  var endRadius = cameraRadius();
  var startZoom = camera.zoom;
  var endZoom = 1;
  var endX = endRadius * Math.cos(theta * Math.PI / 180.0) * Math.cos(phi * Math.PI / 180.0) + aim.x; // X in OpenStudio coordinates
  var endY = endRadius * Math.sin(phi * Math.PI / 180.0) + aim.y; // Z in OpenStudio coordinates
  var endZ = -endRadius * Math.sin(theta * Math.PI / 180.0) * Math.cos(phi * Math.PI / 180.0) + aim.z; // Y in OpenStudio coordinates
  
  if (doTween){
    var target = {
      progress: 0,
      start: {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z,
        r: startRadius,
        theta: Math.acos(camera.position.z / startRadius),
        phi: Math.atan2(camera.position.y, camera.position.x),
        zoom: startZoom
      },
      end: {
        x: endX,
        y: endY,
        z: endZ,
        r: endRadius,
        theta: Math.acos(endZ / endRadius),
        phi: Math.atan2(endY, endX),
        zoom: endZoom
      }
    };
    /*console.debug('===========================');
    console.debug('START');
    console.debug('x: ' + camera.position.x + '    y: ' + camera.position.y + '    z: ' + camera.position.z);
    console.debug('θ: ' + (target.start.theta * 180 / Math.PI).toFixed(3) + '°    φ: ' + (target.start.phi * 180 / Math.PI).toFixed(3) + '°');
    console.debug('END');
    console.debug('x: ' + position.x + '    y: ' + position.y + '    z: ' + position.z);
    console.debug('θ: ' + (target.end.theta * 180 / Math.PI).toFixed(3) + '°    φ: ' + (target.end.phi * 180 / Math.PI).toFixed(3) + '°');
    console.debug('===========================');*/
    TweenLite.to(target, 1, {
      progress: 1,
      ease: Power3.easeInOut,
      onUpdate: function (tween) {
        var r = tween.target.start.r + tween.target.progress * (tween.target.end.r - tween.target.start.r);
        var theta = tween.target.start.theta + tween.target.progress * (tween.target.end.theta - tween.target.start.theta);
        var phi = tween.target.start.phi + tween.target.progress * (tween.target.end.phi - tween.target.start.phi);
        var zoom = tween.target.start.zoom + tween.target.progress * (tween.target.end.zoom - tween.target.start.zoom);
        var x = r * Math.sin(theta) * Math.cos(phi);
        var y = r * Math.sin(theta) * Math.sin(phi);
        var z = r * Math.cos(theta); 
        //console.debug('θ: ' + (theta * 180 / Math.PI).toFixed(3) + '°    φ: ' + (phi * 180 / Math.PI).toFixed(3) + '°');
        camera.position.set(x, y, z);
        camera.zoom = zoom;
        camera.updateProjectionMatrix();
      },
      onUpdateParams: ["{self}"]
    });
    
  }else{
    camera.position.set(endX, endY, endZ);
    camera.zoom = endZoom;
    camera.updateProjectionMatrix();
  }
};

function init() {

  var css = document.head.appendChild(document.createElement('style'));
  css.innerHTML = 'body { font:600 12pt monospace; margin:0; overflow:hidden; }';

  info = document.body.appendChild(document.createElement('div'));
  info.style.cssText = 'left:20px; position:absolute; top:0; width:100%;';
  info.innerHTML = '<div id=msg></div>';

  // Heads Up
  headsUp = document.body.appendChild(document.createElement('div'));
  headsUp.style.cssText = 'background-color:#ddd; border-radius:8px; padding:0 5px 10px; opacity:0.85; position:absolute; left:50px; text-align:left; z-index:10;';

  renderer = new THREE.WebGLRenderer({
    alpha: 1,
    antialias: true,
    clearColor: 0xffffff
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMapEnabled = true;
  renderer.shadowMapSoft = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  
  aspect = window.innerWidth / window.innerHeight;
  orthographicCamera = new THREE.OrthographicCamera( 4*aspect*os_data.metadata.boundingBox.lookAtR / - 2, 4*aspect*os_data.metadata.boundingBox.lookAtR / 2, 4*os_data.metadata.boundingBox.lookAtR / 2, 4*os_data.metadata.boundingBox.lookAtR / - 2, 1, 5000 );
  scene.add(orthographicCamera); // for light to follow
  orthographicCamera.lookAt(cameraLookAt());
  orthographicCamera.up.set(0,1,0);
  
  perspectiveCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
  scene.add(perspectiveCamera); // for light to follow
  perspectiveCamera.lookAt(cameraLookAt());
  perspectiveCamera.up.set(0,1,0);
  
  camera = perspectiveCamera;
  
  setCameraAngles(-30, 30, false);

  // Controls
  orthographicControls = new THREE.OrbitControls(orthographicCamera, renderer.domElement);
  orthographicControls.minDistance = 10;
  orthographicControls.maxDistance = 1000;
  orthographicControls.enabled = false;
  
  perspectiveControls = new THREE.OrbitControls(perspectiveCamera, renderer.domElement);
  perspectiveControls.minDistance = 10;
  perspectiveControls.maxDistance = 1000;
  perspectiveControls.enabled = true;
  
  controls = perspectiveControls;

  // Lights
  light = new THREE.AmbientLight(0xbbbbbb);
  scene.add(light);

  var axisHelper = new THREE.AxisHelper(50);
  scene.add(axisHelper);

  project = new THREE.Object3D();
  scene.add(project);
  
  var loader = new THREE.ObjectLoader();
  data = loader.parse(os_data);
  project.add(data);
  
  scene_objects = project.children[0].children;
  for ( object of scene_objects ) {
    edges = new THREE.EdgesHelper( object, 0x000000 );
    scene.add( edges );
  }
  
  var sg = new THREE.SphereGeometry( 1, 32, 32 ); 
  var sm = new THREE.MeshBasicMaterial( {color: 0xff0000} ); 
  var s = new THREE.Mesh( sg, sm ); 
  scene.add( s );
  s.position.set(cameraLookAt().x, cameraLookAt().y, cameraLookAt().z);
  console.log(s);
  
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  selected_material = new THREE.MeshPhongMaterial({
    color: 0xffff00,
    ambient: 0xffff00,
    specular: 0xffff00,
    emissive: 0xffff00,
    shininess: 50,
    side: THREE.DoubleSide
  });
  
  materials = parseMaterials(os_data.materials);

  document.addEventListener('click', onDocumentMouseClick, false);
}


function onDocumentMouseClick(event) {
  mouse.x = (event.clientX / renderer.domElement.width) * 2 - 1;
  mouse.y = -(event.clientY / renderer.domElement.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  intersects = raycaster.intersectObjects(project.children[0].children);

  if (intersects.length) {
    // new intersected object
    if (intersected != intersects[0].object) {
      // restore material on deselected
      if (intersected && intersected.lastMaterial) {
        intersected.material = intersected.lastMaterial;
      }

      intersected = intersects[0].object;

      // save material
      if (intersected && intersected.material) {
        intersected.lastMaterial = intersected.material;
      }

      intersected.material = selected_material;

      headsUp.style.left = 10 + 0.5 * window.innerWidth + mouse.x * 0.5 * window.innerWidth + 'px';
      headsUp.style.top = -10 + 0.5 * window.innerHeight - mouse.y * 0.5 * window.innerHeight + 'px';
      headsUp.style.display = '';

      var txt;
      switch (settings.renderBy) {
        case "Surface Type":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Surface Type: ' + intersected.userData.surfaceType + '<br>' +
                'Space Name: ' + intersected.userData.spaceName + '<br>' +
                '';
          break;
        case "Boundary":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Outside Boundary Condition: ' + intersected.userData.outsideBoundaryCondition + '<br>' +
                'Sun Exposure: ' + intersected.userData.sunExposure + '<br>' +
                'Wind Exposure: ' + intersected.userData.windExposure + '<br>' +
                '';
          break;
        case "Construction":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Construction Name: ' + intersected.userData.constructionName + '<br>' +
                '';
          break;
        case "Thermal Zone":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Thermal Zone: ' + intersected.userData.thermalZoneName + '<br>' +
                '';
          break;
        case "Space Type":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Space Type: ' + intersected.userData.spaceTypeName + '<br>' +
                '';
          break;        
        case "Building Story":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Story Name: ' + intersected.userData.buildingStoryName + '<br>' +
                '';
          break;
        case "Data":
          break;        
      }

      headsUp.innerHTML = txt;

    }

    document.body.style.cursor = 'pointer';
  } else {
    // restore material on deselected
    if (intersected && intersected.lastMaterial) {
      intersected.material = intersected.lastMaterial;
    }

    intersected = null;
    headsUp.style.display = 'none';
    document.body.style.cursor = 'auto';
  }

}

function animate(timestamp) {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

settings = {
  renderBy: 'Surface Type',
  showStory: 'All Stories',
  zoomExtents: function () {
    console.log('View: extents');
  },
  xView: function(){ setCameraAngles(0, 0, true); },
  yView: function(){ setCameraAngles(-90, 0, true); },
  zView: function(){ setCameraAngles(0, 90, true); },
  reset: function(){ setCameraAngles(-30, 30, true); },
  orthographic: false,
  xSection: 0,
  ySection: 0,
  zSection: 0
};

var update = function (value) {

  renderBy = settings.renderBy;
  showStory = settings.showStory;
  allStories = (showStory == 'All Stories');

  scene_objects = project.children[0].children;
  for ( object of scene_objects ) {
  
    object.visible = true;
  
    if (allStories || showStory == object.userData.buildingStoryName){
      // no-op
    }else{
      object.visible = false;
    }
    
    var material = null;
    switch (renderBy) {
      case "Surface Type":
        material = materials[object.userData.surfaceTypeMaterialName];
        break;
      case "Boundary":
        material = materials[object.userData.boundaryMaterialName];
        break;
      case "Construction":
        material = materials[object.userData.constructionMaterialName];
        break;
      case "Thermal Zone":
        material = materials[object.userData.thermalZoneMaterialName];
        break;
      case "Space Type":
        material = materials[object.userData.spaceTypeMaterialName];
        break;        
      case "Building Story":
        material = materials[object.userData.buildingStoryMaterialName];
        break;
      case "Data":
        break;        
    }
  
    object.material = material;
    if ( material != null){
      object.material.needsUpdate = true; 
    }
  }
};

window.onload = function() {
  var gui = new dat.GUI();
    gui.add(settings, 'renderBy', ['Surface Type', 'Boundary', 'Construction', 'Thermal Zone', 'Space Type', 'Building Story', 'Data']).name('Render By').onChange(update);
    
    building_story_names = os_data.metadata.buildingStoryNames;
    building_story_names.unshift('All Stories');
    gui.add(settings, 'showStory', building_story_names).name('Show Story').onChange(update);
    
    var f1 = gui.addFolder('Camera');
    f1.add(settings, 'orthographic').name('Orthographic').onChange( function(newValue){
      if (newValue){
        orthographicCamera.position.set(perspectiveCamera.position.x, perspectiveCamera.position.y, perspectiveCamera.position.z);
        //orthographicCamera.zoom = perspectiveCamera.zoom;
        camera = orthographicCamera;
        orthographicControls.enabled = true;
        perspectiveControls.enabled = false;
        controls = orthographicControls;
      }else{
        perspectiveCamera.position.set(orthographicCamera.position.x, orthographicCamera.position.y, orthographicCamera.position.z);
        //perspectiveCamera.zoom = orthographicCamera.zoom;
        camera = perspectiveCamera;
        orthographicControls.enabled = false;
        perspectiveControls.enabled = true;
        controls = perspectiveControls;        
      }
    });
    f1.add(settings, 'xView').name('X View');
    f1.add(settings, 'yView').name('Y View');
    f1.add(settings, 'zView').name('Z View');
    f1.add(settings, 'reset').name('Reset');
    f1.open();
    //var f2 = gui.addFolder('Section Cut');
    //f2.add(settings, 'xSection', 0, 360).name('X Section').onChange(function (value) {
    //  console.log('X cut: ' + value);
    //});
    //f2.add(settings, 'ySection', 0, 360).name('Y Section').onChange(function (value) {
    //  console.log('Y cut: ' + value);
    //});
    //f2.add(settings, 'zSection', 0, 360).name('Z Section').onChange(function (value) {
    //  console.log('Z cut: ' + value);
    //});
    //f2.open();
    
    update();
};
</script>
</body>
</html>