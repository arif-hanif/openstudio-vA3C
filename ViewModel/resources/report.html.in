<!DOCTYPE html>
<html>
<head>
<title>OpenStudio Model</title>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<script src="http://mrdoob.github.io/three.js/build/three.min.js"></script>
<script src="http://mrdoob.github.io/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.16.1/TweenLite.min.js"></script>
</head>
<body>
<script>
var os_data = <%=os_data %>;
var info, renderer, scene, light, scene_objects, coincident_objects, back_objects;
var perspectiveCamera, orthographicCamera, perspectiveControls, orthographicControls;
var project, materials;

var raycaster;
var mouse;
var intersected, selected_material, selected_material_back;

var settings = {
  renderBy: 'Surface Type',
  showStory: 'All Stories',
  showFloors: true,
  showWalls: true,
  showRoofCeilings: true,
  showWindows: true,
  showDoors: true,
  showShading: true,
  xView: function(){ setAllCameraAngles(0, 0, 1); },
  yView: function(){ setAllCameraAngles(-90, 0, 1); },
  zView: function(){ setAllCameraAngles(0, 90, 1); },
  reset: function(){ setAllCameraAngles(-30, 30, 1); },
  orthographic: false,
  xSection: 0,
  ySection: 0,
  zSection: 0
};

init();
animate();

function parseMaterials(json) {
  var materials = {};
  var loader = new THREE.MaterialLoader();
  for ( var i = 0, l = json.length; i < l; i ++ ) {
    var data = json[ i ];
    var material = loader.parse( data );
    material.uuid = data.uuid;
    material.name = data.name;
    materials[ data.name ] = material;
  }
  return materials;
};

function cameraLookAt() {
  return new THREE.Vector3(os_data.metadata.boundingBox.lookAtX, os_data.metadata.boundingBox.lookAtZ, -os_data.metadata.boundingBox.lookAtY);
};

function cameraRadius() {
  return 4 * os_data.metadata.boundingBox.lookAtR;
};

function setAllCameraAngles(theta, phi, tweenTime) {
  perspectiveTweenTime = tweenTime;
  orthographicTweenTime = tweenTime;
  if (settings.orthographic){
    perspectiveTweenTime = 0;
  }else{
    orthographicTweenTime = 0;
  }
  setCameraAngles(perspectiveCamera, perspectiveControls, theta, phi, perspectiveTweenTime);
  setCameraAngles(orthographicCamera, orthographicControls, theta, phi, orthographicTweenTime);
};

// theta is rotation about OpenStudio Z in degrees, phi is rotation above ground plane in degrees
function setCameraAngles(camera, controls, theta, phi, tweenTime) {
  var aim = cameraLookAt();
  
  var startRadius = Math.sqrt(Math.pow(camera.position.x - aim.x, 2) + Math.pow(camera.position.y - aim.y, 2) + Math.pow(camera.position.z - aim.z, 2));
  var endRadius = cameraRadius();
  var endX = endRadius * Math.cos(theta * Math.PI / 180.0) * Math.cos(phi * Math.PI / 180.0) + aim.x; // X in OpenStudio coordinates
  var endY = endRadius * Math.sin(phi * Math.PI / 180.0) + aim.y; // Z in OpenStudio coordinates
  var endZ = -endRadius * Math.sin(theta * Math.PI / 180.0) * Math.cos(phi * Math.PI / 180.0) + aim.z; // Y in OpenStudio coordinates
  
  var target = {
    progress: 0,
    start: {
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z,
      r: startRadius,
      theta: Math.acos(camera.position.z / startRadius),
      phi: Math.atan2(camera.position.y, camera.position.x),
      upX: camera.up.x,
      upY: camera.up.y,
      upZ: camera.up.z,
      lookAtX: controls.target.x,
      lookAtY: controls.target.y,
      lookAtZ: controls.target.z,
      targetX: controls.target.x,
      targetY: controls.target.y,
      targetZ: controls.target.z,
      zoom: camera.zoom
    },
    end: {
      x: endX,
      y: endY,
      z: endZ,
      r: endRadius,
      theta: Math.acos(endZ / endRadius),
      phi: Math.atan2(endY, endX),
      upX: 0,
      upY: 1,
      upZ: 0,
      lookAtX: aim.x,
      lookAtY: aim.y,
      lookAtZ: aim.z,
      targetX: aim.x,
      targetY: aim.y,
      targetZ: aim.z,
      zoom: 1
    }
  };

  TweenLite.to(target, tweenTime, {
    progress: 1,
    ease: Power3.easeInOut,
    onUpdate: function (tween) {
      var r = tween.target.start.r + tween.target.progress * (tween.target.end.r - tween.target.start.r);
      var theta = tween.target.start.theta + tween.target.progress * (tween.target.end.theta - tween.target.start.theta);
      var phi = tween.target.start.phi + tween.target.progress * (tween.target.end.phi - tween.target.start.phi);
      var zoom = tween.target.start.zoom + tween.target.progress * (tween.target.end.zoom - tween.target.start.zoom);
      var x = r * Math.sin(theta) * Math.cos(phi);
      var y = r * Math.sin(theta) * Math.sin(phi);
      var z = r * Math.cos(theta); 
      var upX = tween.target.start.upX + tween.target.progress * (tween.target.end.upX - tween.target.start.upX);
      var upY = tween.target.start.upY + tween.target.progress * (tween.target.end.upY - tween.target.start.upY);
      var upZ = tween.target.start.upZ + tween.target.progress * (tween.target.end.upZ - tween.target.start.upZ);
      var lookAtX = tween.target.start.lookAtX + tween.target.progress * (tween.target.end.lookAtX - tween.target.start.lookAtX);
      var lookAtY = tween.target.start.lookAtY + tween.target.progress * (tween.target.end.lookAtY - tween.target.start.lookAtY);
      var lookAtZ = tween.target.start.lookAtZ + tween.target.progress * (tween.target.end.lookAtZ - tween.target.start.lookAtZ);
      var targetX = tween.target.start.targetX + tween.target.progress * (tween.target.end.targetX - tween.target.start.targetX);
      var targetY = tween.target.start.targetY + tween.target.progress * (tween.target.end.targetY - tween.target.start.targetY);
      var targetZ = tween.target.start.targetZ + tween.target.progress * (tween.target.end.targetZ - tween.target.start.targetZ);
      
      camera.position.set(x, y, z);
      camera.zoom = zoom;
      camera.up.set(upX, upY, upZ);
      camera.lookAt(new THREE.Vector3(lookAtX, lookAtY, lookAtZ));
      camera.updateProjectionMatrix();
      
      controls.target = new THREE.Vector3(targetX, targetY, targetZ);
    },
    onUpdateParams: ["{self}"],
    onComplete: function () {
      camera.position.set(endX, endY, endZ);
      camera.zoom = 1;
      camera.up.set(0, 1, 0);
      camera.lookAt(aim);
      camera.updateProjectionMatrix();
      
      controls.target = aim;
    }
  });
};

function init() {

  var css = document.head.appendChild(document.createElement('style'));
  css.innerHTML = 'body { font:600 12pt monospace; margin:0; overflow:hidden; }';

  info = document.body.appendChild(document.createElement('div'));
  info.style.cssText = 'left:20px; position:absolute; top:0; width:100%;';
  info.innerHTML = '<div id=msg></div>';

  // Heads Up
  headsUp = document.body.appendChild(document.createElement('div'));
  headsUp.style.cssText = 'background-color:#ddd; border-radius:8px; padding:0 5px 10px; opacity:0.85; position:absolute; left:50px; text-align:left; z-index:10;';

  renderer = new THREE.WebGLRenderer({
    alpha: 1,
    antialias: true,
    clearColor: 0xffffff
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMapEnabled = true;
  renderer.shadowMapSoft = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  
  aspect = window.innerWidth / window.innerHeight;
  orthographicCamera = new THREE.OrthographicCamera( 4*aspect*os_data.metadata.boundingBox.lookAtR / - 2, 4*aspect*os_data.metadata.boundingBox.lookAtR / 2, 4*os_data.metadata.boundingBox.lookAtR / 2, 4*os_data.metadata.boundingBox.lookAtR / - 2, 1, 5000 );
  scene.add(orthographicCamera); // for light to follow
  orthographicCamera.up.set(0,1,0);
  orthographicCamera.lookAt(cameraLookAt());

  perspectiveCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
  scene.add(perspectiveCamera); // for light to follow
  perspectiveCamera.up.set(0,1,0);
  perspectiveCamera.lookAt(cameraLookAt());

  // Controls
  orthographicControls = new THREE.OrbitControls(orthographicCamera, renderer.domElement);
  orthographicControls.minDistance = 10;
  orthographicControls.maxDistance = 1000;
  orthographicControls.enabled = true;
  
  perspectiveControls = new THREE.OrbitControls(perspectiveCamera, renderer.domElement);
  perspectiveControls.minDistance = 10;
  perspectiveControls.maxDistance = 1000;
  perspectiveControls.enabled = true;
  
  // initialize camera and controls
  setAllCameraAngles(-30, 30, 0);

  // Lights
  light = new THREE.AmbientLight(0xbbbbbb);
  scene.add(light);

  var axisHelper = new THREE.AxisHelper(50);
  scene.add(axisHelper);

  project = new THREE.Object3D();
  scene.add(project);
  
  var loader = new THREE.ObjectLoader();
  data = loader.parse(os_data);
  project.add(data);
  
  // scene_objects is an array of THREE.Mesh where each mesh is a real OpenStudio object
  scene_objects = project.children[0].children;
  
  // temp is a map of OpenStudio handle to scene object
  var temp = {};
  for ( object of scene_objects ) {
    temp[object.userData.handle] = object;
  }
  
  // coincident_objects store references between adjacent objects that are truly coincident, meaning that their vertices are completely the same
  coincident_objects = {}
  for ( object of scene_objects ) {
    if (object.userData.coincidentWithOutsideObject){
      coincident_objects[object.uuid] = temp[object.userData.outsideBoundaryConditionObjectHandle];
    }
  }
  
  // back_objects are copies of scene_objects that exist only so we can color their back sides
  // objects that have coincident objects do not get a back object
  back_objects = {};
  for ( object of scene_objects ) {
    edges = new THREE.EdgesHelper( object, 0x000000 );
    scene.add(edges);
    edge = scene.children[scene.children.length-1];
    
    if (coincident_objects[object.uuid] == null){
      back_object = object.clone();
      back_object.visible = false;
      back_object.name = back_object.name + ' Back';
      scene.add(back_object);
      back_object = scene.children[scene.children.length-1];
      back_object.geometry = object.geometry.clone();
      back_objects[object.uuid] = back_object;
    }
  }
  
  // show look at point
  //var sg = new THREE.SphereGeometry( 1, 32, 32 ); 
  //var sm = new THREE.MeshBasicMaterial( {color: 0xff0000} ); 
  //var s = new THREE.Mesh( sg, sm ); 
  //scene.add( s );
  //s.position.set(cameraLookAt().x, cameraLookAt().y, cameraLookAt().z);
  
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  selected_material = new THREE.MeshPhongMaterial({
    name: 'Selected',
    color: 0xffff00,
    ambient: 0xffff00,
    specular: 0xffff00,
    emissive: 0xffff00,
    shininess: 50,
    side: THREE.DoubleSide
  });
  
  selected_material_back = new THREE.MeshPhongMaterial({
    name: 'Selected Back',
    color: 0xffff00,
    ambient: 0xffff00,
    specular: 0xffff00,
    emissive: 0xffff00,
    shininess: 50,
    opacity: 0,
    transparent: true,
    side: THREE.FrontSide
  });
  
  materials = parseMaterials(os_data.materials);

  document.addEventListener('click', onDocumentMouseClick, false);
}


function onDocumentMouseClick(event) {
  mouse.x = (event.clientX / renderer.domElement.width) * 2 - 1;
  mouse.y = -(event.clientY / renderer.domElement.height) * 2 + 1;

  if (settings.orthographic){
    raycaster.setFromCamera(mouse, orthographicCamera);
  }else{
    raycaster.setFromCamera(mouse, perspectiveCamera);
  }
  
  // raycaster intersects invisible objects so filter first
  var pickable = scene_objects.filter(function(x){return x.visible});
  intersects = raycaster.intersectObjects(pickable);
  if (intersects.length) {
    // new intersected object
    if (intersected != intersects[0].object) {
    
      // restore material on deselected
      if (intersected && intersected.lastMaterial) {
        intersected.material = intersected.lastMaterial;
        intersected.material.needsUpdate = true;
        intersected.lastMaterial = null;
      }
      if (intersected){
        coincident_intersected = coincident_objects[intersected.uuid];
        if (coincident_intersected && coincident_intersected.lastMaterial) {
          coincident_intersected.visible = true;
          coincident_intersected.material = coincident_intersected.lastMaterial;
          coincident_intersected.material.needsUpdate = true;
          coincident_intersected.lastMaterial = null;
        }      
        back_intersected = back_objects[intersected.uuid];
        if (back_intersected && back_intersected.lastMaterial) {
          back_intersected.visible = true;
          back_intersected.material = back_intersected.lastMaterial;
          back_intersected.material.needsUpdate = true;
          back_intersected.lastMaterial = null;
        }
      }
    
      // figure out which object we intersected, we did not test back objects
      intersected = intersects[0].object;
      coincident_intersected = coincident_objects[intersected.uuid];
      back_intersected = back_objects[intersected.uuid];

      // save last material and set new one
      if (intersected) {
        intersected.lastMaterial = intersected.material;
        intersected.material = selected_material;
        intersected.material.needsUpdate = true;      
      }
      if (coincident_intersected) {        
        coincident_intersected.lastMaterial = coincident_intersected.material;
        coincident_intersected.material = selected_material_back;
        coincident_intersected.material.needsUpdate = true;
        coincident_intersected.visible = false; 
      }   
      if (back_intersected) {
        back_intersected.lastMaterial = back_intersected.material;
        back_intersected.material = selected_material_back;
        back_intersected.material.needsUpdate = true;
        back_intersected.visible = false;
      }      

      headsUp.style.left = 10 + 0.5 * window.innerWidth + mouse.x * 0.5 * window.innerWidth + 'px';
      headsUp.style.top = -10 + 0.5 * window.innerHeight - mouse.y * 0.5 * window.innerHeight + 'px';
      headsUp.style.display = '';

      var txt;
      switch (settings.renderBy) {
        case "Surface Type":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Surface Type: ' + intersected.userData.surfaceType + '<br>' +
                'Space Name: ' + intersected.userData.spaceName + '<br>' +
                '';
          break;
        case "Normal":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Surface Type: ' + intersected.userData.surfaceType + '<br>' +
                'Space Name: ' + intersected.userData.spaceName + '<br>' +
                '';
          break;          
        case "Boundary":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Outside Boundary Condition: ' + intersected.userData.outsideBoundaryCondition + '<br>' +
                'Sun Exposure: ' + intersected.userData.sunExposure + '<br>' +
                'Wind Exposure: ' + intersected.userData.windExposure + '<br>' +
                '';
          break;
        case "Construction":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Construction Name: ' + intersected.userData.constructionName + '<br>' +
                '';
          break;
        case "Thermal Zone":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Thermal Zone: ' + intersected.userData.thermalZoneName + '<br>' +
                '';
          break;
        case "Space Type":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Space Type: ' + intersected.userData.spaceTypeName + '<br>' +
                '';
          break;        
        case "Building Story":
          txt = 'Name: ' + intersected.userData.name + '<br>' +
                'Story Name: ' + intersected.userData.buildingStoryName + '<br>' +
                '';
          break;
        case "Data":
          break;        
      }

      headsUp.innerHTML = txt;

    }

    document.body.style.cursor = 'pointer';
  } else {
    // restore material on deselected
    if (intersected && intersected.lastMaterial) {
      intersected.material = intersected.lastMaterial;
      intersected.material.needsUpdate = true;
      intersected.lastMaterial = null;
    }
    if (intersected){
      coincident_intersected = coincident_objects[intersected.uuid];
      if (coincident_intersected && coincident_intersected.lastMaterial) {
        coincident_intersected.visible = true;
        coincident_intersected.material = coincident_intersected.lastMaterial;
        coincident_intersected.material.needsUpdate = true;
        coincident_intersected.lastMaterial = null;
      }    
      back_intersected = back_objects[intersected.uuid];
      if (back_intersected && back_intersected.lastMaterial) {
        console.log('restoring 2');
        back_intersected.visible = true;
        back_intersected.material = back_intersected.lastMaterial;
        back_intersected.material.needsUpdate = true;
        back_intersected.lastMaterial = null;
      }
    }

    intersected = null;
    headsUp.style.display = 'none';
    document.body.style.cursor = 'auto';
  }

}

function animate(timestamp) {
  requestAnimationFrame(animate);
  orthographicControls.update();
  perspectiveControls.update();
  if (settings.orthographic){
    renderer.render(scene, orthographicCamera);
  }else{
    renderer.render(scene, perspectiveCamera);
  }
};

var update = function (value) {

  renderBy = settings.renderBy;
  showStory = settings.showStory;
  allStories = (showStory == 'All Stories');
  
  showFloors = settings.showFloors;
  showWalls = settings.showWalls;
  showRoofCeilings = settings.showRoofCeilings;
  showWindows = settings.showWindows;
  showDoors = settings.showDoors;
  showShading = settings.showShading;

  for ( object of scene_objects ) {
  
    surfaceType = object.userData.surfaceType;
  
    object.visible = true;
  
    if (allStories || showStory == object.userData.buildingStoryName){
      // no-op
    }else{
      object.visible = false;
    }
    
    if (!showFloors && surfaceType == 'Floor'){
      object.visible = false;
    }else if (!showWalls && surfaceType == 'Wall'){
      object.visible = false;
    }else if (!showRoofCeilings && surfaceType == 'RoofCeiling'){
      object.visible = false;
    }else if (!showWindows && surfaceType.indexOf('Window') > -1){
      object.visible = false;
    }else if (!showDoors && surfaceType.indexOf('Door') > -1){
      object.visible = false;
    }else if (!showShading && (surfaceType.indexOf('Shading') > -1)){
      object.visible = false;
    }
    
    var material = null;
    var material_back = null;
    switch (renderBy) {
      case "Surface Type":
        if (coincident_objects[object.uuid] == null){
          material = materials[object.userData.surfaceTypeMaterialName];
        }else{
          material = materials[object.userData.surfaceTypeMaterialName + '_Int'];
        }
        material_back = materials[object.userData.surfaceTypeMaterialName + '_Int'];
        break;
      case "Normal":
        if (coincident_objects[object.uuid] == null){
          material = materials['NormalMaterial'];
        }else{
          material = materials['NormalMaterial_Int'];
        }
        material_back = materials['NormalMaterial_Int'];
        break;
      case "Boundary":
        material = materials[object.userData.boundaryMaterialName];
        break;
      case "Construction":
        material = materials[object.userData.constructionMaterialName];
        break;
      case "Thermal Zone":
        material = materials[object.userData.thermalZoneMaterialName];
        break;
      case "Space Type":
        material = materials[object.userData.spaceTypeMaterialName];
        break;        
      case "Building Story":
        material = materials[object.userData.buildingStoryMaterialName];
        break;
      case "Data":
        break;        
    }
  
    object.material = material;
    if ( material != null){
      object.material.needsUpdate = true; 
    }
    
    back_object = back_objects[object.uuid];
    if (back_object != null){
      back_object.material = material_back;
      if ( material_back != null){
        back_object.visible = object.visible;
        back_object.material.needsUpdate = true; 
      }else{
        back_object.visible = false;
      }
    }
  }
};

window.onload = function() {
  var gui = new dat.GUI();
  gui.add(settings, 'renderBy', ['Surface Type', 'Normal', 'Boundary', 'Construction', 'Thermal Zone', 'Space Type', 'Building Story', 'Data']).name('Render By').onChange(update);
  
  building_story_names = os_data.metadata.buildingStoryNames;
  building_story_names.unshift('All Stories');
  gui.add(settings, 'showStory', building_story_names).name('Show Story').onChange(update);
  
  var f1 = gui.addFolder('Surface Filters');
  f1.add(settings, 'showFloors').name('Show Floors').onChange(update);
  f1.add(settings, 'showWalls').name('Show Walls').onChange(update);
  f1.add(settings, 'showRoofCeilings').name('Show Roofs').onChange(update);
  f1.add(settings, 'showWindows').name('Show Windows').onChange(update);
  f1.add(settings, 'showDoors').name('Show Doors').onChange(update);
  f1.add(settings, 'showShading').name('Show Shading').onChange(update);
  f1.open();

  var f2 = gui.addFolder('Camera');
  f2.add(settings, 'orthographic').name('Orthographic');
  f2.add(settings, 'xView').name('X View');
  f2.add(settings, 'yView').name('Y View');
  f2.add(settings, 'zView').name('Z View');
  f2.add(settings, 'reset').name('Reset');
  f2.open();
  
  //var f2 = gui.addFolder('Section Cut');
  //f2.add(settings, 'xSection', 0, 360).name('X Section').onChange(function (value) {
  //  console.log('X cut: ' + value);
  //});
  //f2.add(settings, 'ySection', 0, 360).name('Y Section').onChange(function (value) {
  //  console.log('Y cut: ' + value);
  //});
  //f2.add(settings, 'zSection', 0, 360).name('Z Section').onChange(function (value) {
  //  console.log('Z cut: ' + value);
  //});
  //f2.open();
  
  //if (os_data.metadata.hasData){
    var f3 = gui.addFolder('Data Rendering');
    f3.add(settings, 'orthographic').name('Orthographic');
    f3.add(settings, 'xView').name('X View');
    f3.add(settings, 'yView').name('Y View');
    f3.add(settings, 'zView').name('Z View');
    f3.add(settings, 'reset').name('Reset');
    f3.open();
  //}
  
  update();
};
</script>
</body>
</html>