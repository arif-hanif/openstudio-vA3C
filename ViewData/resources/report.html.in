<!DOCTYPE html>
<html>
<head>
<title>OpenStudio Model</title>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script>
<script src="http://mrdoob.github.io/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.16.1/TweenLite.min.js"></script>
</head>
<body>
<script>
var os_data = <%=os_data %>;
var info, renderer, scene, light, scene_objects, scene_edges, object_edges, coincident_objects, back_objects;
var perspectiveCamera, orthographicCamera, perspectiveControls, orthographicControls;
var project, materials;

var raycaster;
var mouse;
var intersected, selected_material, selected_material_back;

var settings = {
  renderBy: 'Surface Type',
  showStory: 'All Stories',
  showFloors: true,
  showWalls: true,
  showRoofCeilings: true,
  showWindows: true,
  showDoors: true,
  showShading: true,
  showWireframe: false,
  xView: function(){ setAllCameraAngles(0, 0, 1); },
  yView: function(){ setAllCameraAngles(-90, 0, 1); },
  zView: function(){ setAllCameraAngles(0, 90, 1); },
  reset: function(){ setAllCameraAngles(-30, 30, 1); },
  orthographic: false,
  xSection: 0,
  ySection: 0,
  zSection: 0
};

init();
animate();

function parseMaterials(json) {
  var materials = {};
  var loader = new THREE.MaterialLoader();
  for ( var i = 0, l = json.length; i < l; i ++ ) {
    var data = json[ i ];
    var material = loader.parse( data );
    material.uuid = data.uuid;
    material.name = data.name;
    materials[ data.name ] = material;
  }
  return materials;
};

function cameraLookAt() {
  return new THREE.Vector3(os_data.metadata.boundingBox.lookAtX, os_data.metadata.boundingBox.lookAtZ, -os_data.metadata.boundingBox.lookAtY);
};

function cameraRadius() {
  return 4 * os_data.metadata.boundingBox.lookAtR;
};

function setAllCameraAngles(theta, phi, tweenTime) {
  perspectiveTweenTime = tweenTime;
  orthographicTweenTime = tweenTime;
  if (settings.orthographic){
    perspectiveTweenTime = 0;
  }else{
    orthographicTweenTime = 0;
  }
  setCameraAngles(perspectiveCamera, perspectiveControls, theta, phi, perspectiveTweenTime);
  setCameraAngles(orthographicCamera, orthographicControls, theta, phi, orthographicTweenTime);
};

// theta is rotation about OpenStudio Z in degrees, phi is rotation above ground plane in degrees
function setCameraAngles(camera, controls, theta, phi, tweenTime) {
  var aim = cameraLookAt();
  
  var startRadius = Math.sqrt(Math.pow(camera.position.x - aim.x, 2) + Math.pow(camera.position.y - aim.y, 2) + Math.pow(camera.position.z - aim.z, 2));
  var endRadius = cameraRadius();
  var endX = endRadius * Math.cos(theta * Math.PI / 180.0) * Math.cos(phi * Math.PI / 180.0) + aim.x; // X in OpenStudio coordinates
  var endY = endRadius * Math.sin(phi * Math.PI / 180.0) + aim.y; // Z in OpenStudio coordinates
  var endZ = -endRadius * Math.sin(theta * Math.PI / 180.0) * Math.cos(phi * Math.PI / 180.0) + aim.z; // Y in OpenStudio coordinates
  
  var endUpX = 0;
  var endUpY = 1;
  var endUpZ = 0;
  if (phi == 90){
    var endUpX = 0;
    var endUpY = 1;
    var endUpZ = -0.01;  
  }
  
  var target = {
    progress: 0,
    start: {
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z,
      r: startRadius,
      theta: Math.acos(camera.position.z / startRadius),
      phi: Math.atan2(camera.position.y, camera.position.x),
      upX: camera.up.x,
      upY: camera.up.y,
      upZ: camera.up.z,
      lookAtX: controls.target.x,
      lookAtY: controls.target.y,
      lookAtZ: controls.target.z,
      targetX: controls.target.x,
      targetY: controls.target.y,
      targetZ: controls.target.z,
      zoom: camera.zoom
    },
    end: {
      x: endX,
      y: endY,
      z: endZ,
      r: endRadius,
      theta: Math.acos(endZ / endRadius),
      phi: Math.atan2(endY, endX),
      upX: endUpX,
      upY: endUpY,
      upZ: endUpZ,
      lookAtX: aim.x,
      lookAtY: aim.y,
      lookAtZ: aim.z,
      targetX: aim.x,
      targetY: aim.y,
      targetZ: aim.z,
      zoom: 1
    }
  };

  TweenLite.to(target, tweenTime, {
    progress: 1,
    ease: Power3.easeInOut,
    onUpdate: function (tween) {
      var r = tween.target.start.r + tween.target.progress * (tween.target.end.r - tween.target.start.r);
      var theta = tween.target.start.theta + tween.target.progress * (tween.target.end.theta - tween.target.start.theta);
      var phi = tween.target.start.phi + tween.target.progress * (tween.target.end.phi - tween.target.start.phi);
      var zoom = tween.target.start.zoom + tween.target.progress * (tween.target.end.zoom - tween.target.start.zoom);
      var x = r * Math.sin(theta) * Math.cos(phi);
      var y = r * Math.sin(theta) * Math.sin(phi);
      var z = r * Math.cos(theta); 
      var upX = tween.target.start.upX + tween.target.progress * (tween.target.end.upX - tween.target.start.upX);
      var upY = tween.target.start.upY + tween.target.progress * (tween.target.end.upY - tween.target.start.upY);
      var upZ = tween.target.start.upZ + tween.target.progress * (tween.target.end.upZ - tween.target.start.upZ);
      var lookAtX = tween.target.start.lookAtX + tween.target.progress * (tween.target.end.lookAtX - tween.target.start.lookAtX);
      var lookAtY = tween.target.start.lookAtY + tween.target.progress * (tween.target.end.lookAtY - tween.target.start.lookAtY);
      var lookAtZ = tween.target.start.lookAtZ + tween.target.progress * (tween.target.end.lookAtZ - tween.target.start.lookAtZ);
      var targetX = tween.target.start.targetX + tween.target.progress * (tween.target.end.targetX - tween.target.start.targetX);
      var targetY = tween.target.start.targetY + tween.target.progress * (tween.target.end.targetY - tween.target.start.targetY);
      var targetZ = tween.target.start.targetZ + tween.target.progress * (tween.target.end.targetZ - tween.target.start.targetZ);
      
      camera.position.set(x, y, z);
      camera.zoom = zoom;
      camera.up.set(upX, upY, upZ);
      camera.lookAt(new THREE.Vector3(lookAtX, lookAtY, lookAtZ));
      camera.updateProjectionMatrix();
      
      controls.target = new THREE.Vector3(targetX, targetY, targetZ);
    },
    onUpdateParams: ["{self}"],
    onComplete: function () {
      camera.position.set(endX, endY, endZ);
      camera.zoom = 1;
      camera.up.set(endUpX, endUpY, endUpZ);
      camera.lookAt(aim);
      camera.updateProjectionMatrix();
      
      controls.target = aim;
    }
  });
};

function init() {

  var css = document.head.appendChild(document.createElement('style'));
  css.innerHTML = 'body { font:600 12pt monospace; margin:0; overflow:hidden; }';

  info = document.body.appendChild(document.createElement('div'));
  info.style.cssText = 'left:20px; position:absolute; top:0; width:100%;';
  info.innerHTML = '<div id=msg></div>';

  // Heads Up
  headsUp = document.body.appendChild(document.createElement('div'));
  headsUp.style.cssText = 'background-color:#ddd; border-radius:8px; padding:0 5px 10px; opacity:0.85; position:absolute; left:50px; text-align:left; z-index:10;';

  renderer = new THREE.WebGLRenderer({
    alpha: 1,
    antialias: true,
    clearColor: 0xffffff
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMapEnabled = true;
  renderer.shadowMapSoft = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  
  aspect = window.innerWidth / window.innerHeight;
  orthographicCamera = new THREE.OrthographicCamera( 4*aspect*os_data.metadata.boundingBox.lookAtR / - 2, 4*aspect*os_data.metadata.boundingBox.lookAtR / 2, 4*os_data.metadata.boundingBox.lookAtR / 2, 4*os_data.metadata.boundingBox.lookAtR / - 2, 1, 5000 );
  scene.add(orthographicCamera); // for light to follow
  orthographicCamera.up.set(0,1,0);
  orthographicCamera.lookAt(cameraLookAt());

  perspectiveCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
  scene.add(perspectiveCamera); // for light to follow
  perspectiveCamera.up.set(0,1,0);
  perspectiveCamera.lookAt(cameraLookAt());

  // Controls
  orthographicControls = new THREE.OrbitControls(orthographicCamera, renderer.domElement);
  orthographicControls.minDistance = 10;
  orthographicControls.maxDistance = 1000;
  orthographicControls.enabled = true;
  
  perspectiveControls = new THREE.OrbitControls(perspectiveCamera, renderer.domElement);
  perspectiveControls.minDistance = 10;
  perspectiveControls.maxDistance = 1000;
  perspectiveControls.enabled = true;
  
  // initialize camera and controls
  setAllCameraAngles(-30, 30, 0);

  // Lights
  light = new THREE.AmbientLight(0xbbbbbb);
  scene.add(light);

  // Axes, adapted from AxisHelper.js
  var axisSize = cameraRadius();
  
  var xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 }); 
  var xAxisGeometry = new THREE.Geometry(); 
  xAxisGeometry.vertices.push( new THREE.Vector3(0,0,0), new THREE.Vector3(axisSize,0,0)); 
  scene.add( new THREE.Line( xAxisGeometry, xAxisMaterial ) );
  
  var yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 }); 
  var yAxisGeometry = new THREE.Geometry(); 
  yAxisGeometry.vertices.push( new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-axisSize)); 
  scene.add( new THREE.Line( yAxisGeometry, yAxisMaterial ) );
  
  var zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff }); 
  var zAxisGeometry = new THREE.Geometry(); 
  zAxisGeometry.vertices.push( new THREE.Vector3(0,0,0), new THREE.Vector3(0,axisSize,0)); 
  scene.add( new THREE.Line( zAxisGeometry, zAxisMaterial ) );
  
  // scene
  project = new THREE.Object3D();
  scene.add(project);
  
  var loader = new THREE.ObjectLoader();
  data = loader.parse(os_data);
  project.add(data);
  
  // scene_objects is an array of THREE.Mesh where each mesh is a real OpenStudio object
  scene_objects = project.children[0].children;
  
  // temp is a map of OpenStudio handle to scene object
  var temp = {};
  for ( object of scene_objects ) {
    temp[object.userData.handle] = object;
  }
  
  // coincident_objects store references between adjacent objects that are truly coincident, meaning that their vertices are completely the same
  // when an object's coincident object is visible we do not want to show the back object
  coincident_objects = {}
  for ( object of scene_objects ) {
    if (object.userData.coincidentWithOutsideObject){
      coincident_objects[object.uuid] = temp[object.userData.outsideBoundaryConditionObjectHandle];
    }
  }
  
  // back_objects are copies of scene_objects that exist only so we can color their back sides
  scene_edges = [];
  back_objects = {};
  object_edges = {};
  for ( object of scene_objects ) {
    edges = new THREE.EdgesHelper( object, 0x000000 );
    scene.add(edges);
    edge = scene.children[scene.children.length-1];
    scene_edges.push(edge);
    object_edges[object.uuid] = edge;
    
    back_object = object.clone();
    back_object.visible = false;
    back_object.name = back_object.name + ' Back';
    scene.add(back_object);
    back_object = scene.children[scene.children.length-1];
    back_object.geometry = object.geometry.clone();
    back_objects[object.uuid] = back_object;
  }
  
  // show look at point
  //var sg = new THREE.SphereGeometry( 1, 32, 32 ); 
  //var sm = new THREE.MeshBasicMaterial( {color: 0xff0000} ); 
  //var s = new THREE.Mesh( sg, sm ); 
  //scene.add( s );
  //s.position.set(cameraLookAt().x, cameraLookAt().y, cameraLookAt().z);
  
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  selected_material = new THREE.MeshPhongMaterial({
    name: 'Selected',
    color: 0xffff00,
    ambient: 0xffff00,
    specular: 0xffff00,
    emissive: 0xffff00,
    shininess: 50,
    side: THREE.DoubleSide
  });
  
  materials = parseMaterials(os_data.materials);

  document.addEventListener('click', onDocumentMouseClick, false);
};

function setSelectedMaterial(object) {
  //console.log("Selecting " + object.name);
  
  object.wasVisible = object.visible;
  object.lastMaterial = object.material;
  object.visible = true;
  object.material = selected_material;
  object.material.needsUpdate = true;     
};

function removeMaterial(object) {
  //console.log("Removing material from " + object.name);
  
  object.wasVisible = object.visible;
  object.lastMaterial = object.material;
  object.visible = false;
  object.material = null
};

function restoreLastMaterial(object) {
  //console.log("Restoring last material to " + object.name);
  
  object.visible = object.wasVisible;
  object.material = object.lastMaterial;
  if (object.material){
    object.material.needsUpdate = true;
  }
  object.lastMaterial = null;
};

function selectObject(object) {
  if (intersected != object){
  
    // restore material on currently selected
    if (intersected) {
      restoreLastMaterial(intersected);
      
      coincident_intersected = coincident_objects[intersected.uuid];
      if (coincident_intersected) {
        restoreLastMaterial(coincident_intersected);
      }      
      
      back_intersected = back_objects[intersected.uuid];
      if (back_intersected) {
        restoreLastMaterial(back_intersected);
      }
    }
    
    // set the new intersected objects
    intersected = object;
    
    // save last material and set new one
    if (intersected) {
      setSelectedMaterial(intersected);    
      
      coincident_intersected = coincident_objects[intersected.uuid];
      if (coincident_intersected) {  
        removeMaterial(coincident_intersected);
      }   
      
      back_intersected = back_objects[intersected.uuid];
      if (back_intersected) {
        removeMaterial(back_intersected);
      }   
    }
  }
};

function onDocumentMouseClick(event) {
  mouse.x = (event.clientX / renderer.domElement.width) * 2 - 1;
  mouse.y = -(event.clientY / renderer.domElement.height) * 2 + 1;

  if (settings.orthographic){
    raycaster.setFromCamera(mouse, orthographicCamera);
  }else{
    raycaster.setFromCamera(mouse, perspectiveCamera);
  }
  
  // raycaster intersects invisible objects so filter first
  var pickable = scene_objects.filter(function(x){return x.visible});
  intersects = raycaster.intersectObjects(pickable);
  if (intersects.length) {
  
    selectObject(intersects[0].object);

    headsUp.style.left = 10 + 0.5 * window.innerWidth + mouse.x * 0.5 * window.innerWidth + 'px';
    headsUp.style.top = -10 + 0.5 * window.innerHeight - mouse.y * 0.5 * window.innerHeight + 'px';
    headsUp.style.display = '';

    var txt;
    switch (settings.renderBy) {
      case "Surface Type":
        txt = 'Name: ' + intersected.userData.name + '<br>' +
              'Surface Type: ' + intersected.userData.surfaceType + '<br>' +
              'Space Name: ' + intersected.userData.spaceName + '<br>' +
              '';
        break;
      case "Normal":
        txt = 'Name: ' + intersected.userData.name + '<br>' +
              'Surface Type: ' + intersected.userData.surfaceType + '<br>' +
              'Space Name: ' + intersected.userData.spaceName + '<br>' +
              '';
        break;          
      case "Boundary":
        txt = 'Name: ' + intersected.userData.name + '<br>' +
              'Outside Boundary Condition: ' + intersected.userData.outsideBoundaryCondition + '<br>' +
              'Sun Exposure: ' + intersected.userData.sunExposure + '<br>' +
              'Wind Exposure: ' + intersected.userData.windExposure + '<br>' +
              '';
        break;
      case "Construction":
        txt = 'Name: ' + intersected.userData.name + '<br>' +
              'Construction Name: ' + intersected.userData.constructionName + '<br>' +
              '';
        break;
      case "Thermal Zone":
        txt = 'Name: ' + intersected.userData.name + '<br>' +
              'Thermal Zone: ' + intersected.userData.thermalZoneName + '<br>' +
              '';
        break;
      case "Space Type":
        txt = 'Name: ' + intersected.userData.name + '<br>' +
              'Space Type: ' + intersected.userData.spaceTypeName + '<br>' +
              '';
        break;        
      case "Building Story":
        txt = 'Name: ' + intersected.userData.name + '<br>' +
              'Story Name: ' + intersected.userData.buildingStoryName + '<br>' +
              '';
        break;
      case "Data":
        break;        
    }

    headsUp.innerHTML = txt;
    document.body.style.cursor = 'pointer';
    
  } else {
    
    selectObject(null);
    headsUp.style.display = 'none';
    document.body.style.cursor = 'auto';
  }

};

function animate(timestamp) {
  requestAnimationFrame(animate);
  orthographicControls.update();
  perspectiveControls.update();
  if (settings.orthographic){
    renderer.render(scene, orthographicCamera);
  }else{
    renderer.render(scene, perspectiveCamera);
  }
};

var update = function (value) {

  selectObject(null);

  renderBy = settings.renderBy;
  showStory = settings.showStory;
  allStories = (showStory == 'All Stories');
  
  showFloors = settings.showFloors;
  showWalls = settings.showWalls;
  showRoofCeilings = settings.showRoofCeilings;
  showWindows = settings.showWindows;
  showDoors = settings.showDoors;
  showShading = settings.showShading;
  showWireframe = settings.showWireframe;

  for ( object of scene_objects ) {
  
    surfaceType = object.userData.surfaceType;
  
    object.visible = true;
  
    if (allStories || showStory == object.userData.buildingStoryName){
      // no-op
    }else{
      object.visible = false;
    }
    
    if (!showFloors && surfaceType == 'Floor'){
      object.visible = false;
    }else if (!showWalls && surfaceType == 'Wall'){
      object.visible = false;
    }else if (!showRoofCeilings && surfaceType == 'RoofCeiling'){
      object.visible = false;
    }else if (!showWindows && surfaceType.indexOf('Window') > -1){
      object.visible = false;
    }else if (!showDoors && surfaceType.indexOf('Door') > -1){
      object.visible = false;
    }else if (!showShading && (surfaceType.indexOf('Shading') > -1)){
      object.visible = false;
    }
    
    var material = null;
    var material_double_sided = null;
    var material_back = null;
    switch (renderBy) {
      case "Surface Type":
        material = materials[object.userData.surfaceTypeMaterialName];
        material_double_sided = material;
        if (coincident_objects[object.uuid]){
          // coincident object present, only show inside face
          material = materials[object.userData.surfaceTypeMaterialName + '_Int'];
        }
        material_back = materials[object.userData.surfaceTypeMaterialName + '_Int'];
        break;
      case "Normal":
        material = materials['NormalMaterial'];
        material_double_sided = material;
        if (coincident_objects[object.uuid]){
          // coincident object present, only show inside face
          material = materials['NormalMaterial_Int'];
        }
        material_back = materials['NormalMaterial_Int'];
        break;
      case "Boundary":
        material = materials[object.userData.boundaryMaterialName];
        break;
      case "Construction":
        material = materials[object.userData.constructionMaterialName];
        break;
      case "Thermal Zone":
        material = materials[object.userData.thermalZoneMaterialName];
        break;
      case "Space Type":
        material = materials[object.userData.spaceTypeMaterialName];
        break;        
      case "Building Story":
        material = materials[object.userData.buildingStoryMaterialName];
        break;
      case "Data":
        break;        
    }
  
    object.material = material;
    object.material_double_sided = material_double_sided;
    if ( material != null){
      object.material.needsUpdate = true; 
    }
    
    var edge = object_edges[object.uuid];
    if (showWireframe || object.visible){
      edge.visible = true;
    }else{
      edge.visible = false;    
    }
    
    back_object = back_objects[object.uuid];
    if (back_object){
      back_object.material = material_back;
      if ( material_back != null){
        back_object.visible = object.visible;
        back_object.material.needsUpdate = true; 
      }else{
        back_object.visible = false;
      }
    }
  }
  
  // turn off back objects where coincident objects are visible
  for ( object of scene_objects ) {
    if (object.visible){
      coincident_object = coincident_objects[object.uuid];
      if (coincident_object){
        back_object = back_objects[object.uuid];
        if (back_object){
          if (coincident_object.visible){
            // coincident object is visible, hide back object
            back_object.visible = false;
          }else{
            // coincident object is not visible, show back object
            back_object.visible = true;
            
            if (object.material_double_sided){
              // switch to double sided material so we can select this
              object.material = object.material_double_sided;
              object.material.needsUpdate = true; 
            }
          }
        }
      }
    }
  }
};

window.onload = function() {
  var gui = new dat.GUI();
  gui.add(settings, 'renderBy', ['Surface Type', 'Normal', 'Boundary', 'Construction', 'Thermal Zone', 'Space Type', 'Building Story', 'Data']).name('Render By').onChange(update);
  
  building_story_names = os_data.metadata.buildingStoryNames;
  building_story_names.unshift('All Stories');
  gui.add(settings, 'showStory', building_story_names).name('Show Story').onChange(update);
  
  var f1 = gui.addFolder('Surface Filters');
  f1.add(settings, 'showFloors').name('Show Floors').onChange(update);
  f1.add(settings, 'showWalls').name('Show Walls').onChange(update);
  f1.add(settings, 'showRoofCeilings').name('Show Roofs').onChange(update);
  f1.add(settings, 'showWindows').name('Show Windows').onChange(update);
  f1.add(settings, 'showDoors').name('Show Doors').onChange(update);
  f1.add(settings, 'showShading').name('Show Shading').onChange(update);
  f1.add(settings, 'showWireframe').name('Show Wireframe').onChange(update);
  f1.open();

  var f2 = gui.addFolder('Camera');
  f2.add(settings, 'orthographic').name('Orthographic');
  f2.add(settings, 'xView').name('X View');
  f2.add(settings, 'yView').name('Y View');
  f2.add(settings, 'zView').name('Z View');
  f2.add(settings, 'reset').name('Reset');
  f2.open();
  
  //var f2 = gui.addFolder('Section Cut');
  //f2.add(settings, 'xSection', 0, 360).name('X Section').onChange(function (value) {
  //  console.log('X cut: ' + value);
  //});
  //f2.add(settings, 'ySection', 0, 360).name('Y Section').onChange(function (value) {
  //  console.log('Y cut: ' + value);
  //});
  //f2.add(settings, 'zSection', 0, 360).name('Z Section').onChange(function (value) {
  //  console.log('Z cut: ' + value);
  //});
  //f2.open();
  
  //if (os_data.metadata.hasData){
  //  var f3 = gui.addFolder('Data Rendering');
  //  f3.add(settings, 'orthographic').name('Orthographic');
  //  f3.add(settings, 'xView').name('X View');
  //  f3.add(settings, 'yView').name('Y View');
  //  f3.add(settings, 'zView').name('Z View');
  //  f3.add(settings, 'reset').name('Reset');
  //  f3.open();
  //}
  
  update();
};
</script>
</body>
</html>